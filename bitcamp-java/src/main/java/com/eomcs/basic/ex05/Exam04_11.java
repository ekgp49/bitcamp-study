// 비트 이동 연산자 : 비트이동의 유효 범위
package com.eomcs.basic.ex05;

public class Exam04_11 {
  public static void main(String[] args) {

    System.out.println(3 << 1); // 6
    System.out.println(3 << 33); // 6
    System.out.println(3 << 65); // 6
    System.out.println(3 << 97); // 6

    // 3에 33비트를 이동하나 65비트를 이동하나 97비트를 이동하나 같은 값이 나오는 이유:
    // => int 타입의 값에 대해 비트이동을 할 때에는 0 ~ 31 까지만 유효하다.
    //    만약 31을 넘는 경우 32로 나눈 나머지 값을 비트이동으로 간주한다.
    // int 값에 대한 비트 이동값은 0 ~ 31 이다.
    // long 값에 대한 비트이동값은 0 ~ 63 이다.
    // 비트 이동 유효 범위를 벗어난다면 ?
    // => int 데이터인 경우 비트이동 값은 하위 5비트만 유효하다.
    // => long 데이터인경우 하위 6비트만 유효하다.
    // 공식)
    // n << s
    // 만약 n이 int 타입이라면, 다음 계산을 통해 s의 최종값은 다음과 같다. s & 0b11111 = 비트이동값
    // 만약 n이 long 타입이라면, s & 0b111111 = 비트이동값
    // ex1) n 이 int인 경우
    // 3 << 33
    // n = 00000000 00000000 00000000 00000011 = 3
    // s = 00000000 00000000 00000000 00100001 = 33
    //     00000000 00000000 00000000 00011111
    // s & 0b11111 
    //   = 00000000 00000000 00000000 00000001 = 1
    // 따라서 3 << 33 은 3 << 1과 같다.
    // 결국 s 는  s % 32 와 같다.
    // ex2) n이 long인 경우
    // 결국 s 는  s % 64 와 같다.
    // 3 << 65
    // n = 00000000 00000000 00000000 00000011 = 3
    // s = 00000000 00000000 00000000 00100001 = 33
    //     00000000 00000000 00000000 00011111
    // s & 0b11111 
    //   = 00000000 00000000 00000000 00000001 = 1
    // 비트 이동 계산의 근거 : 는 java language specification에 있음
  }
}
